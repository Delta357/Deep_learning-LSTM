# -*- coding: utf-8 -*-
"""Rede Neural LSTM - Análise sentimento.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11V6mdeq3Jvfx3RSOkzSeFAPNASleO-53
"""

import nltk
import numpy as np
import matplotlib.pyplot as plt

from tensorflow.keras.datasets import imdb
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Embedding, Dense, Dropout
from tensorflow.keras.preprocessing import sequence
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from sklearn.metrics import confusion_matrix, classification_report
from nltk.corpus import stopwords

# Carregar o conjunto de dados IMDB
max_words = 2000
(X_train, y_train), (X_test, y_test) = imdb.load_data(num_words=max_words)

X_train.shape

y_train.shape

# Pré-processamento dos dados
max_review_length = 1000
X_train = sequence.pad_sequences(X_train, maxlen=max_review_length)
X_test = sequence.pad_sequences(X_test, maxlen=max_review_length)

"""# **Rede Neural**"""

# Definir a arquitetura da rede neural LSTM
model = Sequential()
model.add(Embedding(max_words, 128, input_length=max_review_length))
model.add(LSTM(128, return_sequences=True))  # Adiciona uma camada LSTM adicional
model.add(LSTM(64))  # Adiciona outra camada LSTM
model.add(Dense(64, activation='relu'))  # Adiciona uma camada densa com ativação ReLU
model.add(Dropout(0.5))  # Adiciona dropout para regularização
model.add(Dense(1, activation='sigmoid'))

# Compilar o modelo
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

batch_size = 64
epochs = 5

# Summario modelo
model.summary()

# Treinar o modelo
model.fit(X_train,
          y_train,
          validation_data=(X_test, y_test),
          batch_size=batch_size,
          epochs=epochs)

# Avaliar o modelo
scores = model.evaluate(X_test, y_test, verbose=0)
print("Acurácia: %.2f%%" % (scores[1] * 100))

# Fazer previsões
y_pred = model.predict_classes(X_test)

# Imprimir relatório de classificação
print("Relatório de Classificação:")
print(classification_report(y_test, y_pred))

# Plotar a matriz de confusão
plt.imshow(confusion, interpolation='nearest', cmap=plt.cm.Blues)
plt.title("Matriz de Confusão")
plt.colorbar()
plt.xticks([0, 1], ['Negativo', 'Positivo'])
plt.yticks([0, 1], ['Negativo', 'Positivo'])
plt.xlabel('Previsto')
plt.ylabel('Verdadeiro')
plt.show()

